{"version":3,"sources":["components/Header/Toggle.js","components/Header/Header.js","components/Search/Filter.js","components/Search/PlacesList.js","components/Search/GoogleMap.js","components/Search/Search.js","App.js","serviceWorker.js","index.js"],"names":["Toggle","state","isToggleOn","handleClick","_this","setState","prevState","props","showPlaceList","_this2","this","react_default","a","createElement","className","id","onClick","onKeyDown","event","keyCode","role","tabIndex","aria-label","aria-owns","viewBox","x","y","fill","width","height","d","stroke","strokeWidth","Component","Header","_ref","Header_Toggle","Filter","inputValue","updateInput","updateQuery","htmlFor","lib_default","type","placeholder","value","debounceTimeout","onChange","target","PlacesList","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","buttons","focusedIdx","focusedButton","refList","React","createRef","prevProps","locations","length","manageFocus","el","current","slice","childNodes","firstButton","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","button","err","return","e","selectPlace","preventDefault","style","background","idx","indexOf","innerText","changeFocus","setAttribute","newFocusedButton","focus","_this$props","ref","map","location","index","aria-labelledby","key","concat","aria-selected","handleKeyDown","name","nodes","Array","prototype","GoogleMap","largeInfowindow","markers","loadGoogleMapAPIJS","src","window","document","getElementsByTagName","script","async","parentNode","insertBefore","initMap","google","maps","Map","myMapContainer","center","lat","lng","zoom","InfoWindow","loadMarkersOnMap","googleError","content","getElementById","hidden","appendChild","animateSelectedPlaceOnMap","placeTitle","_this$state","i","title","setAnimation","Animation","BOUNCE","populateInfoWindow","filterMarkerOnMap","filterText","_this$state2","match","RegExp","escapeRegExp","trim","test","setMap","_this$state3","bounds","LatLngBounds","_loop","marker","mapMarkerToMap","push","addListener","extend","position","fitBounds","place","label","Marker","animation","DROP","selectedPlaceTitle","aria-describedby","rel","href","infowindow","getPosition","setContent","open","setPosition","fetchWikiData","address","wikiurl","wikiElemItem","fetch","then","response","json","data","error","code","info","catch","Search","debounce","query","updateQueryState","filterQuery","handleRequestError","listElement","errorPara","textContent","status","Error","venues","console","log","filteredLocations","isListOpen","filter","Search_Filter","Search_PlacesList","Search_GoogleMap","App","showListView","components_Header_Header","components_Search_Search","Boolean","hostname","ReactDOM","render","src_App_0","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.88236936.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nclass Toggle extends Component {\n  state = { isToggleOn: true }\n\n  handleClick = () => {\n    this.setState(prevState => ({\n      isToggleOn: !prevState.isToggleOn,\n    }));\n    this.props.showPlaceList();\n  }\n\n  render() {\n    const { isToggleOn } = this.state;\n    return (\n      <div className=\"menu_logo\">\n        <div\n          id=\"menu\"\n          onClick={this.handleClick}\n          onKeyDown={event => (event.keyCode === 13) && this.handleClick()}\n          role=\"menu\"\n          tabIndex=\"0\"\n          aria-label=\"menu\"\n          aria-owns=\"mi-0 mi-1 mi-2 mi-3 mi-4 mi-5 mi-6 mi-7 mi-8 mi-9 mi-10 mi-11 mi-12 mi-13 mi-14 mi-15 mi-16 mi-17 mi-18 mi-19 mi-20 mi-21 mi-22 mi-23 mi-24\"\n        >\n          {isToggleOn ? (\n            <svg viewBox=\"0 0 41 41\">\n              <rect x=\"5\" y=\"12\" fill=\"currentColor\" width=\"32px\" height=\"2\" />\n              <rect x=\"5\" y=\"21\" fill=\"currentColor\" width=\"32px\" height=\"2\" />\n              <rect x=\"5\" y=\"30\" fill=\"currentColor\" width=\"32px\" height=\"2\" />\n            </svg>\n          ) : (\n            <svg viewBox=\"0 0 41 41\">\n              <path d=\"M5 12 L36 30\" stroke=\"currentColor\" strokeWidth=\"3\" />\n              <path d=\"M5 30 L36 12\" stroke=\"currentColor\" strokeWidth=\"3\" />\n            </svg>\n          )\n          }\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Toggle;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport Toggle from './Toggle';\n\nconst Header = ({ showPlaceList }) => (\n  <header>\n    <h1 id=\"page-header\">\n      Neighborhood Map\n    </h1>\n    {/* Toggle Component - Hamburger menu icon */}\n    <Toggle showPlaceList={showPlaceList} />\n  </header>\n);\n\n// Add PropTypes validation\nHeader.propTypes = {\n  showPlaceList: PropTypes.func.isRequired,\n};\n\nexport default Header;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport DebounceInput from 'react-debounce-input';\n\nclass Filter extends Component {\n  // Add PropTypes validation\n  static propTypes = {\n    updateQuery: PropTypes.func.isRequired,\n  }\n\n  // App's internal state\n  state = {\n    inputValue: '',\n  }\n\n  updateInput = (inputValue) => {\n    this.setState({ inputValue });\n  }\n\n  render() {\n    const { inputValue } = this.state;\n    const { updateQuery } = this.props;\n    return (\n      <label htmlFor=\"filter-text\">\n        <DebounceInput\n          id=\"filter-text\"\n          type=\"text\"\n          role=\"search\"\n          placeholder=\"Search places by name\"\n          value={inputValue}\n          debounceTimeout={1000}\n          onChange={(event) => {\n            this.updateInput(event.target.value);\n            updateQuery(event.target.value);\n          }}\n        />\n        <span id=\"filter-help\">\n          Filter\n        </span>\n      </label>\n    );\n  }\n}\n\nexport default Filter;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\n// Define values for keycodes\nconst VK_ENTER = 13;\nconst VK_SPACE = 32;\nconst VK_LEFT = 37;\nconst VK_UP = 38;\nconst VK_RIGHT = 39;\nconst VK_DOWN = 40;\n\nclass PlacesList extends Component {\n  // Helper function to convert NodeLists to Arrays\n  static slice = nodes => Array.prototype.slice.call(nodes);\n\n  // Add PropTypes validation\n  static propTypes = {\n    locations: PropTypes.instanceOf(Array).isRequired,\n    selectPlace: PropTypes.func.isRequired,\n  };\n\n  constructor(props) {\n    super(props);\n    this.refList = React.createRef();\n  }\n\n  state = {\n    buttons: [],\n    focusedIdx: 0,\n    focusedButton: {},\n  }\n\n  componentDidUpdate(prevProps) {\n    const { locations } = this.props;\n    if (locations.length > 0 && prevProps.locations !== locations) {\n      this.manageFocus();\n    }\n  }\n\n  manageFocus() {\n    // const id = window.document.getElementById('#places-list');\n    const el = this.refList.current;\n    const buttons = PlacesList.slice(el.childNodes);\n    const focusedIdx = 0;\n    const focusedButton = buttons[focusedIdx];\n\n    let firstButton = true;\n    for (const button of buttons) {\n      if (firstButton) {\n        button.tabIndex = '0';\n        firstButton = false;\n      } else {\n        button.tabIndex = '-1';\n      }\n    }\n    this.setState({ buttons, focusedIdx, focusedButton });\n  }\n\n  handleKeyDown(e) {\n    const { selectPlace } = this.props;\n    const { buttons } = this.state;\n    let { focusedIdx } = this.state;\n    switch (e.keyCode) {\n      case VK_UP:\n      case VK_LEFT: {\n        e.preventDefault();\n        focusedIdx -= 1;\n        if (focusedIdx < 0) {\n          focusedIdx += buttons.length;\n        }\n        break;\n      }\n      case VK_DOWN:\n      case VK_RIGHT: {\n        e.preventDefault();\n        focusedIdx = (focusedIdx + 1) % buttons.length;\n        break;\n      }\n      case VK_ENTER:\n      case VK_SPACE: {\n        e.preventDefault();\n        const focusedButton = e.target;\n        focusedButton.style.background = '#454545';\n        const idx = buttons.indexOf(focusedButton);\n        if (idx < 0) {\n          return;\n        }\n        focusedIdx = idx;\n        selectPlace(e.target.innerText);\n        break;\n      }\n      default:\n        return;\n    }\n    this.changeFocus(buttons, focusedIdx);\n  }\n\n  handleClick(e) {\n    const { buttons } = this.state;\n    let { focusedIdx } = this.state;\n    const button = e.target;\n    button.style.background = '#454545';\n    const idx = buttons.indexOf(button);\n    if (idx < 0) {\n      return;\n    }\n    focusedIdx = idx;\n\n    this.changeFocus(buttons, focusedIdx);\n  }\n\n  changeFocus(buttons, focusedIdx) {\n    const { focusedButton } = this.state;\n    // Set the old button to tabindex -1\n    focusedButton.tabIndex = -1;\n    focusedButton.setAttribute('aria-selected', false);\n    focusedButton.style.background = 'black';\n\n    // Set the new button to tabindex 0 and focus it\n    const newFocusedButton = buttons[focusedIdx];\n    newFocusedButton.tabIndex = 0;\n    newFocusedButton.focus();\n    newFocusedButton.setAttribute('aria-selected', true);\n    newFocusedButton.style.background = '#454545';\n\n    this.setState({ focusedButton: newFocusedButton, focusedIdx });\n  }\n\n  render() {\n    const { locations, selectPlace } = this.props;\n    return (\n      <ul ref={this.refList} id=\"places-list\" role=\"listbox\" className=\"listbox\">\n        {locations.map((location, index) => (\n          <li aria-labelledby=\"places name\"\n            key={location.id}\n            id={`mi-${index}`}\n            className=\"places-list-item\"\n            role=\"option\" aria-selected=\"false\"\n            onClick={(event) => { this.handleClick(event); selectPlace(event.target.innerText); }}\n            onKeyDown={(event) => { this.handleKeyDown(event); }}\n          >\n            {location.name}\n          </li>\n        ))}\n      </ul>\n    );\n  }\n}\n\nexport default PlacesList;\n","import React, { Component } from 'react';\nimport escapeRegExp from 'escape-string-regexp';\nimport PropTypes from 'prop-types';\n\nclass GoogleMap extends Component {\n  /**\n   * This function is used to create markers on the map\n   * @param:\n   *      place (data type: object): location detail of the place\n   *      map (data type: object): Google map object\n   *      i (data type: integer): index of the place in the location array\n   * @returns:\n   *      marker(data type: object): new Google Marker object for given place\n   */\n  static mapMarkerToMap(place, map, i) {\n    // Extract first letter from the place name and use it as marker's label\n    const label = place.name[0];\n    const marker = new window.google.maps.Marker({\n      // Use property shorthand of ES6 syntax in place of map: map,\n      map,\n      position: { lat: place.location.lat, lng: place.location.lng },\n      title: place.name,\n      animation: window.google.maps.Animation.DROP,\n      id: i,\n      label,\n    });\n    return marker;\n  }\n\n  /**\n   * This function populates the infowindow with wiki link about the place\n   * when the marker is clicked. We use use fetch API to get data from\n   * Wiki API endpoints. It opens and anchores at the marker that is clicked.\n   * @param:\n   *      marker(data type: object): marker object for the selected/clicked place\n   *      map (data type: object): Google map object\n   *      infowindow (data type: object): Google infowindow object from app's state\n   * @returns:\n   *      None\n   */\n  static populateInfoWindow = (map, marker, infowindow) => {\n    // Check to make sure the infowindow is not already opened on this marker.\n    if (infowindow.getPosition() !== marker.position) {\n      if (infowindow.marker) {\n        infowindow.marker.setAnimation(null);\n      }\n\n      // Animate the marker clicked or place selcted from the place list\n      marker.setAnimation(window.google.maps.Animation.BOUNCE);\n      infowindow.marker = marker;\n      infowindow.setContent(`<div>${marker.title}</div>`);\n      infowindow.open(map, marker);\n      /**\n       * Make sure the marker property is cleared if the infowindow is closed.\n       * Also reset the position of the infowindow\n       */\n      infowindow.addListener('closeclick', () => {\n        infowindow.setPosition(null);\n        marker.setAnimation(null);\n      });\n\n      // Fetch the third party wiki api data for the given place to show inside infowindow\n      GoogleMap.fetchWikiData(marker, infowindow);\n    }\n  };\n\n  /**\n   * This function is used to make asynchronous call to Wiki API and\n   * We use use fetch API to get data and populate the infowindow with the data\n   * also it shows error message in infowindow if API call fails\n   * @param:\n   *      marker(data type: object): marker object for the selected/clicked place\n   *      infowindow (data type: object): Google infowindow object from app's state\n   * @returns:\n   *      None\n   */\n  static fetchWikiData = (marker, infowindow) => {\n    const address = marker.title;\n    // Wiki fetch API url\n    const wikiurl = `https://en.wikipedia.org/w/api.php?&origin=*&action=opensearch&format=json&search=${address}`;\n    // HTML block for the content to be shown inside infowindow\n    let wikiElemItem = `<div role=\"dialog\" class=\"infowindow\" tabindex=\"0\" aria-labelledby=\"infowindow-help\">\n      <h2>${address}</h2>\n      <p id=\"infowindow-help\">Relevant Wikipedia Links</p>\n    <ul>`;\n\n    // fetch API call to retrieve data from Wikipedia\n    fetch(wikiurl)\n      .then(response => response.json())\n      .then((data) => {\n        // Check if the response is an error object\n        if (data.error && data.error.code && data.error.info) {\n          throw data.error.info;\n        }\n        for (let i = 0; i < data.length; i += 1) {\n          // Build the content of infowindow\n          wikiElemItem += data[i].length\n            ? `<li class=\"infowindow-item\">\n                <a target =\"_blank\" href=http://en.wikipedia.org/wiki/${data[i]}>\n                  ${data[i]}\n                </a>\n            </li>`\n            : '';\n        }\n        wikiElemItem += '</ul></div>';\n        // Set the content for infowindow\n        infowindow.setContent(wikiElemItem);\n      })\n      // Catch any error in the Fetch API or javascript error\n      .catch((error) => {\n        wikiElemItem += `<p class='error' style='color:red'>${error}</p></ul></div>`;\n        // Set the error content for infowindow if anything fails\n        infowindow.setContent(wikiElemItem);\n      });\n  };\n\n  // Add PropTypes validation\n  static propTypes = {\n    locations: PropTypes.instanceOf(Array).isRequired,\n    filterText: PropTypes.string.isRequired,\n    selectedPlaceTitle: PropTypes.string.isRequired,\n  }\n\n  constructor(props) {\n    super(props);\n    // Use createRef() to create a reference to the DOM node we want\n    this.myMapContainer = React.createRef();\n  }\n\n  // App's internal state\n  state = {\n    map: null,\n    largeInfowindow: null,\n    markers: [],\n  }\n\n  /**\n   * This is a lifecycle hook which runs immediate after the component\n   * output has been rendered to the DOM.\n   */\n  componentDidMount() {\n    /**\n     * Add the initMap() callback method & googleError onerror method to window\n     * to make initMap from react available for Google maps to callback to.\n     */\n    window.initMap = this.initMap;\n    window.googleError = this.googleError;\n    // If Google map is already available, invoke the initMap()\n    if (typeof window.google === 'object' && typeof window.google.maps === 'object') {\n      this.initMap();\n    } else {\n      // Invoke this method to put the async googleapi script in the DOM\n      this.loadGoogleMapAPIJS('https://maps.googleapis.com/maps/api/js?key=AIzaSyBtsirN68OAeo4fv8o0iEOZ5dJlEAHLUxA&callback=initMap');\n    }\n  }\n\n  /**\n   * This method is invoked immediately after updating occurs.\n   * It is not called for the initial render.You may call setState()\n   * immediately in componentDidUpdate() but note that it must be wrapped in a condition\n   */\n  componentDidUpdate(prevProps) {\n    // destructure the props object into individual variables\n    const { filterText, selectedPlaceTitle, locations } = this.props;\n    // destructure the app's state object into individual variables\n    const { map } = this.state;\n    // Invoke the filterMarkerOnMap() if the props is changed\n    if (filterText !== prevProps.filterText) {\n      this.setState({ markers: this.filterMarkerOnMap(filterText) });\n    }\n    // Invoke the animateSelectedPlaceOnMap() whenever a new place is selected/clicked\n    if (selectedPlaceTitle !== prevProps.selectedPlaceTitle) {\n      this.setState({ markers: this.animateSelectedPlaceOnMap(selectedPlaceTitle) });\n    }\n    // Invoke the loadMarkersOnMap() once the location data is updated in parent component\n    if (locations.length && (locations !== prevProps.locations)) {\n      /**\n       * Do check if the map is initialized or not before loading map markers\n       * And also need avoid creating markers during search rather update\n       * the existing markers in the app's state using filterMarkerOnMap() above\n       */\n      if (map && !filterText) {\n        this.loadMarkersOnMap();\n      }\n    }\n  }\n\n  /**\n   * This function create and add googlemapapis script tag into the DOM\n   * @param:\n   *      src(data type: string): script href tag value\n   * @returns:\n   *      None\n   */\n  loadGoogleMapAPIJS = (src) => {\n    const ref = window.document.getElementsByTagName('script')[0];\n    const script = window.document.createElement('script');\n    script.src = src;\n    script.setAttribute('onerror', 'googleError()');\n    script.async = true;\n    ref.parentNode.insertBefore(script, ref);\n  }\n\n  /**\n   * This function is Google map callback method once map api is loaded successfully\n   * @param:\n   *      None\n   * @returns:\n   *      None\n   */\n  initMap = () => {\n    const { locations } = this.props;\n    // Create google map instance to be added to the DOM\n    const map = new window.google.maps.Map(this.myMapContainer.current, {\n      center: { lat: 26.14, lng: 78.10 },\n      zoom: 6,\n    });\n\n    // Create google map infowindow instance to be added to the DOM\n    const largeInfowindow = new window.google.maps.InfoWindow();\n    // Update the app's state object wirh map, largeInfowindow property\n    this.setState({ map, largeInfowindow });\n    /**\n     * This extra check is to make sure we have the location data\n     * ready before calling the loadMarkersOnMap() method.\n     */\n    if (locations.length) {\n      this.loadMarkersOnMap();\n    }\n  }\n\n  /**\n   * This function is Google map callback method for unwanted map error\n   * @param:\n   *      None\n   * @returns:\n   *      None\n   */\n  googleError = () => {\n    const content = window.document.getElementById('map-error');\n    content.hidden = false;\n    window.document.getElementById('map').appendChild(content);\n  }\n\n  /**\n   * This function filter only the selected place from location list\n   * and sets the Animation property of the specific marker in the app's\n   * markers array state property\n   * @param:\n   *      placeTitle(data type: string): place name for the selected/clicked place\n   * @returns:\n   *      markers(data type: array): updated markers array\n   */\n  animateSelectedPlaceOnMap = (placeTitle) => {\n    // destructure the app's state object into individual variables\n    const { map, markers, largeInfowindow } = this.state;\n\n    // Loop through markers array to find the impacted marker\n    for (let i = 0; i < markers.length; i += 1) {\n      if (placeTitle === markers[i].title) {\n        // set the animation for the selected marker\n        markers[i].setAnimation(window.google.maps.Animation.BOUNCE);\n        // Open the infowindow for the selected marker\n        GoogleMap.populateInfoWindow(map, markers[i], largeInfowindow);\n      } else {\n        // set the animation for the mis matched markers to null\n        markers[i].setAnimation(null);\n      }\n    }\n    // Return the updated markers array\n    return markers;\n  };\n\n  /**\n   * This function filter markers on the Map for the given input text\n   * and sets the map property of the miss matched markers to null\n   * so that it won't appear on the map.\n   * @param:\n   *      filterText(data type: string): marker object for the selected/clicked place\n   * @returns:\n   *      markers(data type: array): updated markers array\n   */\n  filterMarkerOnMap = (filterText) => {\n    // destructure the app's state object into individual variables\n    const { map, markers } = this.state;\n    // Generate the RegEx for user input text\n    const match = new RegExp(escapeRegExp(filterText.trim()), 'i');\n    // Loop through markers array to find the impacted marker\n    for (let i = 0; i < markers.length; i += 1) {\n      // filter the markers based on input text against marker's title\n      if (match.test(markers[i].title)) {\n        markers[i].setMap(map);\n      } else {\n        // set the map for the mis matched markers to null\n        markers[i].setMap(null);\n      }\n    }\n    // Return the updated markers array\n    return markers;\n  }\n\n  /**\n   * This function adds markers to the map during initial load as wel as\n   * updates the markers on map durion place search.\n   * @param:\n   *      None\n   * @returns:\n   *      None\n   */\n  loadMarkersOnMap = () => {\n    // destructure the app's state object into individual variables\n    const { map, largeInfowindow, markers } = this.state;\n    // destructure the app's props object into individual variables\n    const { locations } = this.props;\n\n    // create new map bound instance\n    const bounds = new window.google.maps.LatLngBounds();\n    // The following group uses the location array to create an array of markers on initialize.\n    for (let i = 0; i < locations.length; i += 1) {\n      // Create a marker per location, and put into markers array.\n      const marker = GoogleMap.mapMarkerToMap(locations[i], map, i);\n      // Push the marker to our array of markers.\n      markers.push(marker);\n      /**\n       * Create an onclick event to open an infowindow at each marker.\n       * Using closure to make marker available in callbacks\n       */\n      marker.addListener('click', () => (function captureMarker() {\n        GoogleMap.populateInfoWindow(map, marker, largeInfowindow);\n      }(marker)));\n      // Adjust the map bounds to as per the marker position to fit within the map\n      bounds.extend(marker.position);\n    }\n    // Extend the boundaries of the map for each marker\n    map.fitBounds(bounds);\n  }\n\n  render() {\n    return (\n      <section id=\"maptab\" role=\"application\">\n        {/* HTML block to be used to render the map by Google Map's initMap callback method */}\n        <div ref={this.myMapContainer} id=\"map\" aria-label=\"Places on Map\" aria-describedby=\"map-help\" />\n        {/* HTML block for the mention that the locations are fetched from Foursquare API. */}\n        <div id=\"map-help\">\n          <p>\n            Map showing the places as per the\n            <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://developer.foursquare.com/\">\n              <span> Foursquare API</span>\n            </a>\n          </p>\n        </div>\n        {/* HTML block for googleError callback method by Google Map's onerror attribute */}\n        <div id=\"map-error\" aria-label=\"Can not load the Map\" hidden>\n          <p>\n            <span className=\"error\">\n              \"This page can not load Google Maps correctly.\"\n            </span>\n            <br />\n            <em>\n              Google Map API now requires the use of a valid API Key.\n            </em>\n            <br />\n            <a href=\"https://developers.google.com/maps/documentation/javascript/get-api-key\">\n              Go get one!\n            </a>\n          </p>\n        </div>\n      </section>\n    );\n  }\n}\n\nexport default GoogleMap;\n","import React, { Component } from 'react';\nimport escapeRegExp from 'escape-string-regexp';\nimport PropTypes from 'prop-types';\nimport { debounce } from 'lodash';\nimport Filter from './Filter';\nimport PlacesList from './PlacesList';\nimport GoogleMap from './GoogleMap';\n\nclass Search extends Component {\n  /**\n   * When user type in to filter place, the typed input will only be\n   * processed 300ms after the user's last keystroke. This will reduce the number\n   * of call to updateQueryState() to update the component state hence the rendering.\n   * @param:\n   *      query (data type: string): user input text\n   * @returns:\n   *      None\n   */\n  updateQuery = debounce((query) => { this.updateQueryState(query); }, 300);\n\n  // Add PropTypes validation\n  static propTypes = {\n    isListOpen: PropTypes.bool.isRequired,\n  };\n\n  // App's internal state\n  state = {\n    locations: [],\n    filterQuery: '',\n    selectedPlaceTitle: '',\n  }\n\n  /**\n   * This is a lifecycle hook which runs immediate after the component\n   * output has been rendered to the DOM.\n   */\n  componentDidMount() {\n    // We are making a call to foursquare API once the components are mounted\n    fetch(`https://api.foursquare.com/v2/venues/search?ll=26.14,78.10&client_id=MFWBYGLPDEHOGIVGLHV5NJ15OKXXHGKDQU0VJEROPTKWGVSO&client_secret=KUJCYLVMHE4XX0YINYCEJ0ITW4EQBEHYWLN3C5RDBR5QW43S&limit=25&v=20181117`)\n      .then((response) => {\n        if (response.status === 200) {\n          // return the venue details from the API if request is successful\n          return response.json();\n        }\n        // Throw data not found error if API endpoint respond with status other that 200\n        throw Error('No data found for co-ordinates: 26.14,78.10');\n      })\n      .then((data) => {\n        if (data.response && data.response.venues) {\n          console.log('Fetch Request Successful');\n          const locations = data.response.venues;\n          // Add location details to app internal state\n          this.setState({ locations });\n        } else {\n        // Throw error if the response does not contain venues property\n          throw Error('No venues detail found for co-ordinates: 26.14,78.10');\n        }\n      })\n      // Catch any error in the Fetch API or javascript error\n      .catch(error => this.handleRequestError(error));\n  }\n\n  /**\n   * catch handler for foursquare API request error\n   * it add HTML element with error message to UI\n   * @param:\n   *      error (data type: object): Error object with error details\n   * @returns:\n   *      None\n   */\n  handleRequestError = (error) => {\n    const listElement = window.document.getElementById('places-list');\n    const errorPara = window.document.createElement('p');\n    errorPara.className = 'error';\n    errorPara.textContent = error;\n    errorPara.style = 'color: red';\n    listElement.appendChild(errorPara);\n  }\n\n  /**\n   * This handler function sets the filterQuery with the user entered text on real-time\n   * It is then passed as props to GoogleMap component to filter the map markers on Map\n   * @param:\n   *      filterQuery(data type: string): search text from input field\n   * @returns:\n   *      None\n   */\n  updateQueryState = (filterQuery) => {\n    this.setState({ filterQuery });\n  }\n\n\n  /**\n   * This handler function sets the state property selectedPlaceTitle if a user clicks or select\n   * any place from the place listing. It is then passed as props to GoogleMap component\n   * to animate the selected markers on Map.\n   * @param:\n   *      selectedPlaceTitle(data type: string): title of the selected place from the list\n   * @returns:\n   *      None\n   */\n  selectPlace = (selectedPlaceTitle) => {\n    this.setState({ selectedPlaceTitle });\n  }\n\n  render() {\n    // destructure the app's state object into individual variables\n    const { locations, filterQuery, selectedPlaceTitle } = this.state;\n    const { isListOpen } = this.props;\n    let filteredLocations;\n    if (filterQuery.trim()) {\n      // Generate the RegEx for user input text\n      const match = new RegExp(escapeRegExp(filterQuery.trim()), 'i');\n\n      /**\n        * Filter the location data based on input text against location name\n        * and store the filtered results in new array which will be passed\n        * as props to the GoogleMap and PlaceList component to filer\n        * the shown listing and markers on the map\n      */\n      filteredLocations = locations.filter(location => match.test(location.name));\n    } else {\n      // Use the default set of location if the user enters black text\n      filteredLocations = locations;\n    }\n\n    return (\n      <main aria-label=\"Neighborhood Map\" role=\"main\">\n        <section id=\"placelistview\" className={isListOpen ? 'listview open' : 'listview'}>\n          {/* Search Input component */}\n          <Filter updateQuery={this.updateQuery} />\n          {/* PlaceList component - By default adds all the places as list items on UI */}\n          <PlacesList\n            locations={filteredLocations}\n            selectPlace={this.selectPlace}\n          />\n        </section>\n        {/* GoogleMap component - By default adds map with markers for  all the places on UI */}\n        <GoogleMap\n          locations={filteredLocations}\n          filterText={filterQuery}\n          selectedPlaceTitle={selectedPlaceTitle}\n        />\n      </main>\n    );\n  }\n}\n\nexport default Search;\n","import React, { Component } from 'react';\nimport './App.css';\nimport { Header, Search } from './components';\n\nclass App extends Component {\n// App's internal state\n  state = {\n    isListOpen: false,\n  }\n\n  /**\n   * Even handler for Toggle component,it sets the app state to\n   * indicate if list view is open or closed based on hamburger menu icon\n   * @param:\n   *      None\n   * @returns:\n   *      None\n   */    \t\n  \n  showListView = () => {\n    this.setState(prevState => ({\n      isListOpen: !prevState.isListOpen,\n    }));\n  }\n\n  render() {\n    const { isListOpen } = this.state;\n    return (\n      <div className=\"App\">\n        <Header showPlaceList={this.showListView} />\n        <Search isListOpen={isListOpen} />\n      </div>\n    );\n  }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        trackInstalling(installingWorker);\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n\n/**\n * listen for the installing service worker state\n * and if installed we inform the user about update\n */\nfunction trackInstalling(installingWorker) {\n  installingWorker.addEventListener('statechange', () => {\n    // newWorker.state has changed\n    if (installingWorker.state === 'installed') {\n      if (navigator.serviceWorker.controller) {\n        // At this point, the old content will have been purged and\n        // the fresh content will have been added to the cache.\n        // It's the perfect time to display a \"New content is\n        // available; please refresh.\" message in your web app.\n        console.log('New content is available; please refresh.');\n        updateReady(installingWorker);\n      } else {\n        // At this point, everything has been precached.\n        // It's the perfect time to display a\n        // \"Content is cached for offline use.\" message.\n        console.log('Content is cached for offline use.');\n      }\n    }\n  });\n}\n\nfunction updateReady(worker) {\n  let userConsent = false;\n  userConsent = window.confirm('New version available. Do you want to update?');\n  if (!userConsent) return;\n  // tell the service worker to skipWaiting\n  // console.log('updateSW');\n  worker.postMessage('updateSW');\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}